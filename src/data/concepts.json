{
  "categories": [
    {
      "id": "arrays",
      "name": "Arrays",
      "description": "Ordered collection of elements stored contiguously.",
      "color": "blue",
      "position": { "x": 100, "y": 100 },
      "concepts": [
        {
          "id": "array-access",
          "title": "Array Access",
          "intuition": "Think of an array like numbered mailboxes. You can instantly grab the mail from any box if you know its number!",
          "explanation": "Arrays allow O(1) constant time access to any element using its index, making them efficient for lookups.",
          "complexity": "Access: O(1)",
          "example": "arr[2] gives you the 3rd element instantly, no matter how big the array is."
        },
        {
          "id": "array-insertion",
          "title": "Array Insertion/Deletion",
          "intuition": "Adding or removing an item from the middle of a line of people requires everyone after to shift.",
          "explanation": "When you insert or delete an element in the middle, all subsequent elements must be shifted, resulting in O(n) time complexity.",
          "complexity": "Insert/Delete: O(n)",
          "example": "Inserting at index 0 of [1,2,3] requires shifting all elements right to get [0,1,2,3]."
        },
        {
          "id": "array-search",
          "title": "Array Search",
          "intuition": "Finding a book in an unsorted shelf requires checking each book one by one.",
          "explanation": "In an unsorted array, you must check each element until you find the target, giving O(n) time complexity.",
          "complexity": "Search (unsorted): O(n), Search (sorted): O(log n) with binary search",
          "example": "To find value 5 in [1,9,3,5,2], you need to look at up to all 5 elements."
        }
      ]
    },
    {
      "id": "linked-lists",
      "name": "Linked Lists",
      "description": "Nodes linked by pointers, each containing data and a reference to the next node.",
      "color": "green",
      "position": { "x": 300, "y": 150 },
      "concepts": [
        {
          "id": "linked-list-structure",
          "title": "Linked List Structure",
          "intuition": "Imagine a treasure hunt where each clue points to the location of the next clue.",
          "explanation": "Each node contains data and a pointer to the next node, creating a chain of elements that can be dynamically resized.",
          "complexity": "Space: O(n)",
          "example": "Head -> [1|•] -> [2|•] -> [3|None]"
        },
        {
          "id": "linked-list-operations",
          "title": "Linked List Operations",
          "intuition": "Adding or removing a link in a chain only requires adjusting the connections of adjacent links.",
          "explanation": "Once you have a reference to a node, insertion and deletion can be done in O(1) time by updating pointers.",
          "complexity": "Access: O(n), Insert/Delete (with reference): O(1)",
          "example": "To insert X between B and C in A→B→C, set B.next = X and X.next = C."
        }
      ]
    },
    {
      "id": "stacks",
      "name": "Stacks",
      "description": "LIFO (Last In, First Out) data structure.",
      "color": "purple",
      "position": { "x": 500, "y": 100 },
      "concepts": [
        {
          "id": "stack-operations",
          "title": "Stack Operations",
          "intuition": "Like a stack of plates - you can only take from or add to the top.",
          "explanation": "Stacks follow LIFO (Last In, First Out) principle with two main operations: push (add to top) and pop (remove from top).",
          "complexity": "Push/Pop: O(1)",
          "example": "Stack: [1,2,3] → Push(4) → [1,2,3,4] → Pop() → [1,2,3]"
        },
        {
          "id": "stack-applications",
          "title": "Stack Applications",
          "intuition": "When you need to go back to previous steps in reverse order.",
          "explanation": "Stacks are perfect for problems involving matching, nesting, or tracking history where the most recent item is processed first.",
          "complexity": "Space: O(n)",
          "example": "Function call stack, undo operations, bracket matching, expression evaluation."
        }
      ]
    },
    {
      "id": "queues",
      "name": "Queues",
      "description": "FIFO (First In, First Out) data structure.",
      "color": "orange",
      "position": { "x": 200, "y": 300 },
      "concepts": [
        {
          "id": "queue-operations",
          "title": "Queue Operations",
          "intuition": "Like a line at a ticket counter - first come, first served.",
          "explanation": "Queues follow FIFO (First In, First Out) principle with two main operations: enqueue (add to rear) and dequeue (remove from front).",
          "complexity": "Enqueue/Dequeue: O(1)",
          "example": "Queue: [1,2,3] → Enqueue(4) → [1,2,3,4] → Dequeue() → [2,3,4]"
        },
        {
          "id": "queue-applications",
          "title": "Queue Applications",
          "intuition": "When order of arrival matters and things need to be processed in sequence.",
          "explanation": "Queues are ideal for scheduling, buffering, and processing items in the order they arrive.",
          "complexity": "Space: O(n)",
          "example": "BFS traversal, print job management, handling requests in web servers."
        }
      ]
    },
    {
      "id": "hash-tables",
      "name": "Hash Tables",
      "description": "Key-value pairs stored via hashing.",
      "color": "red",
      "position": { "x": 400, "y": 350 },
      "concepts": [
        {
          "id": "hash-function",
          "title": "Hash Function",
          "intuition": "Like a magical formula that gives each book its own shelf number based on its title.",
          "explanation": "A hash function converts keys into array indices, ideally distributing items evenly to minimize collisions.",
          "complexity": "Hashing: O(1) typically",
          "example": "hash('apple') → 42, so 'apple' gets stored at index 42."
        },
        {
          "id": "hash-operations",
          "title": "Hash Table Operations",
          "intuition": "Find any book in a library instantly if you know its unique catalog number.",
          "explanation": "Hash tables provide extremely fast access, insertion, and deletion on average, though performance degrades with many collisions.",
          "complexity": "Access/Insert/Delete: O(1) average, O(n) worst case",
          "example": "dict = {}; dict['key'] = 'value'; print(dict['key']); del dict['key']"
        }
      ]
    },
    {
      "id": "trees",
      "name": "Trees",
      "description": "Hierarchical nodes with a root and children.",
      "color": "teal",
      "position": { "x": 600, "y": 250 },
      "concepts": [
        {
          "id": "tree-structure",
          "title": "Tree Structure",
          "intuition": "Like a family tree with ancestors at the top, descendants below.",
          "explanation": "A tree is a hierarchical structure with nodes connected by edges, one node designated as root, and no cycles.",
          "complexity": "Space: O(n)",
          "example": "Root node with children, each child can have its own children."
        },
        {
          "id": "tree-traversal",
          "title": "Tree Traversal",
          "intuition": "Different ways to visit everyone in a family tree - parents first or children first.",
          "explanation": "Three main ways to traverse: in-order (left, root, right), pre-order (root, left, right), post-order (left, right, root).",
          "complexity": "Time: O(n)",
          "example": "In-order of [4,2,5,1,3]: 4,2,5,1,3"
        },
        {
          "id": "binary-search-tree",
          "title": "Binary Search Tree",
          "intuition": "A sorted family tree where smaller values go left, larger go right.",
          "explanation": "BSTs maintain order: all left descendants < node < all right descendants, enabling efficient search, insertion, and deletion.",
          "complexity": "Search/Insert/Delete: O(h) where h is height",
          "example": "To find 7 in a BST: check root (5), go right (8), go left (7), found!"
        }
      ]
    },
    {
      "id": "graphs",
      "name": "Graphs",
      "description": "Nodes (vertices) connected by edges.",
      "color": "yellow",
      "position": { "x": 300, "y": 400 },
      "concepts": [
        {
          "id": "graph-types",
          "title": "Graph Types",
          "intuition": "Maps of roads between cities - some one-way, some two-way, some with traffic levels.",
          "explanation": "Graphs can be directed or undirected, weighted or unweighted, cyclic or acyclic, depending on problem needs.",
          "complexity": "Space: O(V + E) or O(V²)",
          "example": "Social networks, road maps, web pages linked to each other."
        },
        {
          "id": "graph-traversal",
          "title": "Graph Traversal",
          "intuition": "Exploring a maze - either go as deep as possible (DFS) or explore level by level (BFS).",
          "explanation": "DFS uses stack (recursion) to explore deep paths first, BFS uses queue to explore breadth first.",
          "complexity": "Time: O(V + E)",
          "example": "BFS finds shortest path in unweighted graph; DFS helps detect cycles."
        }
      ]
    },
    {
      "id": "heaps",
      "name": "Heaps",
      "description": "Tree-based, maintains min/max property.",
      "color": "pink",
      "position": { "x": 500, "y": 450 },
      "concepts": [
        {
          "id": "heap-structure",
          "title": "Heap Structure",
          "intuition": "Like a company where each manager is always more senior than their direct reports.",
          "explanation": "A heap is a complete binary tree where each node has higher (max-heap) or lower (min-heap) priority than its children.",
          "complexity": "Space: O(n)",
          "example": "Min-heap: root is minimum value, each parent ≤ its children."
        },
        {
          "id": "heap-operations",
          "title": "Heap Operations",
          "intuition": "Maintaining the organizational hierarchy when hiring or firing.",
          "explanation": "Insertion adds at bottom, then bubbles up; extract-min/max removes root, replaces with last element, then bubbles down.",
          "complexity": "Insert/Extract-Min/Max: O(log n)",
          "example": "Priority queues, finding k largest/smallest elements."
        }
      ]
    }
  ],
  "connections": [
    { "from": "arrays", "to": "linked-lists", "description": "Sequential access vs. linked access" },
    { "from": "stacks", "to": "queues", "description": "LIFO vs. FIFO" },
    { "from": "trees", "to": "graphs", "description": "Trees are acyclic connected graphs" },
    { "from": "trees", "to": "heaps", "description": "Heaps are specialized trees" },
    { "from": "arrays", "to": "hash-tables", "description": "Hash tables use arrays for buckets" },
    { "from": "linked-lists", "to": "stacks", "description": "Linked lists can implement stacks" },
    { "from": "linked-lists", "to": "queues", "description": "Linked lists can implement queues" }
  ]
} 